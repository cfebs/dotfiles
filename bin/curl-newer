#!/usr/bin/env bash

echoerr() { echo "$@" 1>&2; }
log() { echo ">> $@" 1>&2; }
usage() {
    echoerr "Usage: $0 <unique-file-key> <expire_seconds_in_future> ...curl opts"
    echoerr "Will use curl and store output of file for expire_seconds_in_future seconds"
}

FILE_KEY="$1"
shift 1

if [[ -z "$FILE_KEY" ]]; then
    log "ERROR: no file key provided"
    usage
    exit 1
fi

TRACKING_DIR="${TMPDIR:-/tmp}/curl-newer"
CACHED_FILE="$TRACKING_DIR/$FILE_KEY"
CACHED_FILE_ERR="$TRACKING_DIR/${FILE_KEY}_err"

SECONDS="${1-0}"
shift 1

log "Using options -> key: $FILE_KEY, ttl secs: $SECONDS, curl args: $@"

DO_FETCH=

if [[ -s "$CACHED_FILE_ERR" ]]; then
    # if last attempt was an error, always fetch
    DO_FETCH=1
elif [[ ! -s "$CACHED_FILE" ]]; then
    # if no existing cached file, fetch
    DO_FETCH=1
else
    # date of cache is < now
    EXPIRES=$(($(date -r "$CACHED_FILE" +%s) + SECONDS))
    log "$CACHED_FILE set to expires at $EXPIRES"
    if [[ $EXPIRES < $(date +%s) ]]; then
        log "It expired"
        DO_FETCH=1
    fi
fi

if [[ "$DO_FETCH" ]]; then
    log "Fetching $CACHED_FILE"
    mkdir -p "$TRACKING_DIR"
    curl -o "$CACHED_FILE" -L "$@"
    rc=$?
    if [[ $rc != 0 ]]; then
        log "Error $rc, marking $CACHED_FILE_ERR so next try will fetch"
        touch "$CACHED_FILE_ERR"
    fi
fi

echo "$CACHED_FILE"
